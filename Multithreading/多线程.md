# 多线程

## 1、为什么要有多线程呢？

> 线程
>
> 线程是操作系统能够进行运算调度的最小单位。 它被包含在进程之中，是进程中的实际运作单位。

> 进程
>
> 进程是程序的基本执行实体。

提高效率、同时做多个事情，比如：软件中的耗时操作、所有的聊天软件、所有的服务器



## 2、多线程的两个概念

> 并发
>
> 在同一时刻，有多个指令在单个CPU上交替执行。

> 并行
>
> 在同一时刻，有多个指令在多个CPU上同时执行。



## 3、多线程的实现方式

1. 继承Thread类的方式进行实现

   ```java
   package com.demo01;
   
   public class MyThread extends Thread {
       @Override
       public void run() {
           for (int i = 0;i<100;i++){
               System.out.println(getName()+"：Hello World");
           }
       }
   }
   ```

   ```java
   package com.demo01;
   
   public class ThreadDemo {
       /**
        * 多线程的第一种启动方式
        * 1、自己定义一个类继承Thread
        * 2、重写run方法
        * 3、创建子类的对象，并启动线程
        */
   
       public static void main(String[] args) {
           MyThread t1 = new MyThread();
           MyThread t2 = new MyThread();
   
           t1.setName("Thread1");
           t2.setName("Thread2");
           t1.start();
           t2.start();
       }
   }
   ```

2. 实现Runnable接口的方式进行实现

   ```java
   package com.demo02;
   
   public class MyRun implements Runnable {
       @Override
       public void run() {
           //  书写线程要执行的代码
           for (int i = 0; i < 100; i++) {
               //  获取当前线程对象
               Thread thread = Thread.currentThread();
               //  getName是在Thread里面的
               System.out.println(thread.getName() + "：Hello World!");
           }
       }
   }
   ```

   ```java
   package com.demo02;
   
   public class Thread01 {
       public static void main(String[] args) {
           /*
            * 多线程的第二种启动方式
            * 1、自己定义一个类实现Runnable接口
            * 2、重写里面的run方法
            * 3、创建自己的类的对象
            * 4、创建一个Thread类的对象，并开启线程
            */
   
           //  创建 MyRun的对象
           //  表示多线程要执行的任务
           MyRun myRun = new MyRun();
           //  创建线程对象
           Thread t1 = new Thread(myRun);
           Thread t2 = new Thread(myRun);
           //  设置线程名字
           t1.setName("线程1");
           t2.setName("线程2");
           //  开启线程
           t1.start();
           t2.start();
       }
   }
   ```

3. 利用Callable接口和Future接口方式实现

   ```java
   package com.demo03;
   
   import java.util.concurrent.Callable;
   
   public class MyCallable implements Callable<Object> {
       //  Callable<T>泛型就是返回数据的类型
       @Override
       public Object call() throws Exception {
           //  求1到100之间的和
           int sum = 0;
           for (int i = 1 ;i<101;i++){
               sum += i;
           }
           return sum;
       }
   }
   ```

   ```java
   package com.demo03;
   
   import java.util.concurrent.ExecutionException;
   import java.util.concurrent.FutureTask;
   
   public class Thread03 {
       public static void main(String[] args) throws ExecutionException, InterruptedException {
           /*
               多线程的第三种实现方式
               特点：可以获取到多线程运行的结果
               1、创建一个类MyCallable 实现Callable接口
               2、重写call（是有返回值的，表示多线程运行的结果）
               3、创建MyCallable的对象（表示多线程要执行的任务）
               4、创建Future的对象（作用管理多线程的运行结果）
               5、创建Thread类的对象（表示线程）
            */
   
           //  创建MyCallable的对象（表示多线程要执行的任务）
           MyCallable myCallable = new MyCallable();
           //  Future是一个接口，所以要创建他的实现类对象
           //  创建FutureTask的对象（作用管理多线程运行的结果）
           FutureTask<Object> ft = new FutureTask<>(myCallable);
           //  创建线程对象
           new Thread(ft).start();
           Object o = ft.get();
           System.out.println(o);
       }
   }
   ```

| 三种方式对比     | 优点                                         | 缺点                                       |
| ---------------- | -------------------------------------------- | ------------------------------------------ |
| 继承Thread类     | 编程比较简单，可以直接使用Thread类中的方法   | 可以扩展性较差，不能再继承其他的类         |
| 实现Runnable接口 | 扩展性强，实现该接口的同时还可以继承其他的类 | 编程相对复杂，不能直接使用Thread类中的方法 |
| 实现Callable接口 | 扩展性强，实现该接口的同时还可以继承其他的类 | 编程相对复杂，不能直接使用Thread类中的方法 |



## 4、常见的成员方法

|             方法名称             |                   说明                   |
| :------------------------------: | :--------------------------------------: |
|         String geName()          |             返回此线程的名称             |
|    void setName(String name)     | 设置线程的名字（构造方法也可以设置名字） |
|  static Thread currentThread()   |            获取当前线程的对象            |
|   static void sleep(long time)   |     让线程休眠指定的时间，单位为毫秒     |
|   setPriority(int newPriority)   |             设置线程的优先级             |
|     final int getPriority()      |             获取线程的优先级             |
| final void setDaemon(boolean on) |              设置为守护线程              |
|    public static void yield()    |            出让线程/礼让线程             |
|    public static void join()     |            插入线程/插队线程             |

```java
package com.demoMethod01;

public class MyThreadMethod01 extends Thread {
    public MyThreadMethod01(String name) {
        super(name);
    }

    public MyThreadMethod01() {
    }

    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            System.out.println(getName() + "@" + i);
        }
    }
}
```

```java
package com.demoMethod01;

public class Method01 {
    public static void main(String[] args) throws InterruptedException {
        MyThreadMethod01 t1 = new MyThreadMethod01();
        MyThreadMethod01 t2 = new MyThreadMethod01("线程2");
        t1.setName("线程1");
        t1.start();
        t2.start();
    }
}
```







## 5、线程安全的问题

## 6、死锁

## 7、生产者和消费者