# Redis7高阶

# 1、Redis单线程 VS 多线程

## 1.1、面试题

`redis到底是单线程还是多线程？`

> 这种问法其实并不严谨，为啥这么说呢？
>
> Redis4之后才慢慢支持多线程，直到Redis6/7后才稳定
>
> Redis的版本很多3.x、4.x、6.x，版本不同架构也是不同的，不限定版本问题是否单线程也不太严谨
>
> 1、版本3.x，最早版本，也就是大家口口相传的Redis是单线程
>
> 2、版本4.x，严格意义来说也不是单线程，而是负责处理客户端请求的线程是单线程，但是**开始加了点多线程的东西（异步删除）**。--貌似
>
> 3、2020年5月版本的6.x后及2020年出的7.0版本后，**告别了大家印象中的单线程，用一种全新的多线程来解决问题。**--实锤

`Redis为什么要选择单线程？`

> Redis是单线程
>
> 主要是指Redis的网络IO和键值对读写是由一个线程来完成的，Redis的处理客户端的请时包括获取（Socket读）、解析、执行、内容返回（Socket写）等都由一个顺序串行的主线程序处理，这就是所谓的“单线程”。这也是Redis对外提供键值存储的主要流程。
>
> ![image-20240225204845701](K:\GitHub\notes\Redis\Redis_AD.assets\image-20240225204845701.png)
>
> 但Redis的其他功能，**比如持久化RDB、AOF、异步删除、集群数据同步等等，其实是由额外的线程执行的。Redis命令工作线程是单线程，但是，整个Redis来说，是多线程的**。 
>
> 1. 基于内存操作：Redis的所有数据都存在内存中，因此所有的运算都是内存级别的，所以它的性能比较高。
> 2. 数据结构简单：Redis的数据结构是专门设计的，而这些简单的数据结构的查找和操作的时间大部分复杂度都是O(1)，因此性能比较高。
> 3. 多路复用和非阻塞I/O：Redis使用I/O多路复用功能来监听多个Socket连接客户端，这样就可以使用一个线程连接来处理多个请求，减少线程切换带来的开销，同时避免了I/O阻塞。
> 4. 避免上下文切换：因为是单线程模型，因此就避免了不必要的上下文切换和多线程竞争，这就省去了多线程切换带来的时间和性能上的消耗，而且单线程不会导致死锁问题的发生。



`Redis4.0之前一直采用单线程的主要原因有什么？`

> 简单来说，Redis4.0之前一直采用单线程的主要原因有以下三个：
>
> 1. 使用单线程模型使Redis的开发和维护更简单，因为单线程模型方便开发和调试。
> 2. 即使使用单线程模型也并发的处理了多客户端的请求，主要使用的是I/O多路复用和非阻塞IO。
> 3. 对于Redis系统来说，**主要的性能瓶颈是内存或者网络带宽而并非CPU**。



`既然单线程这么好，为什么逐渐又加入了多线程特性？`

> 正常情况下使用del指令可以很快的删除数据，而当被删除的key是一个非常大的对象时，例如是包含了成千上万个元素的hash集合时，那么del之灵就会造成Redis主线程卡顿。
>
> **这就是Redis3.x单线程时代最经典的故障，大Key删除的头疼问题。**
>
> 由于Redis是单线程，del bigkey
>
> 等待很久这个线程才会释放，类似加了一个synchronized锁，高并发的时候，程序会非常堵。
>
> **解决：**
>
> 1. 使用惰性删除可以有效的避免Redis卡顿的问题。
> 2. 在Redis4.0就引入了多个线程来实现数据的异步惰性删除等功能，但是其处理读写请求的仍然只有一个线程，所以仍然算是狭义上的单线程。



`Unix网络编程中的五种IO模型`

> - Blocking IO -- 阻塞IO
> - NoneBlocking -- 非阻塞IO
> - IO Multiplexing -- IO多路复用
> - Signal Driven IO -- 信号驱动IO
> - Asynchronous IO -- 异步IO



`什么是IO多路复用`

> 1. Linux世界一切接文件
> 2. IO多路复用是什么？
>    1. 一种同步的IO模型，实现**一个线程**监视**多个文件句柄，一旦某个文件句柄就绪**就能够通知对应应程序进行相应的读写操作，**没有文件句柄就绪时**就会阻塞应用程序，从而释放CPU资源
>    2. 概念：
>       - I/O：网络I/O，尤其在操作系统层面指数据在内核态和用户态之间的读写操作
>       - 多路：多个客户端连接（连接就是套接字描述符，即Socket或者Channel）
>       - 复用：复用一个或者几个线程
>       - IO多路复用：也就是说一个或一组线程处理多个TCP连接，使用单进程就能够实现同时处理多个客户端的连接，**无需创建或者维护过多的进程/线程**
> 3. 场景体验，引出Epoll
> 4. 小总结
>    - 只使用一个服务端进程可以同时处理多个套接字描述符连接



`Redis为什么这么快？`

> IO多路复用+epoll函数使用，才是Redis为什么这么快的直接原因，而不是仅仅单线程命令+Redis安装在内存中。



## 1.2、Redis7默认是否开启了多线程？

如果在实际应用中，发现Redis实例的**CPU开销不大但吞吐量却没有提升**，可以考虑使用Redis7的多线程机制，加速网络处理，进而提升实例的吞吐量。

Redis7将所有数据放在内存中，内存的响应时间长大约为100纳秒，对于小数据包，Redis服务器可以处理8W到10W的QPS，这也是Redis处理的极限了，**对于80%的公司来说，单线程的Redis已经足够使用了**。

在Redis6.0及7后，**多线程机制默认是关闭的，如果需要使用多线程功能，需要在Redis.conf中完成两个设置。

![image-20240225224329078](K:\GitHub\notes\Redis\Redis_AD.assets\image-20240225224329078.png)

![image-20240225224614883](K:\GitHub\notes\Redis\Redis_AD.assets\image-20240225224614883.png)



## 1.3、小总结

> Redis自身出道就是优秀，基于内存操作、数据结构简单、多路复用和非阻塞I/O、避免了不必要的线程上下文切换等特性，在单线程的环境下依然很快；
>
> 但对于大数据的Key删除还是卡顿厉害，因此在Redis4.0引入了多线程unlink key / flushall async等命令，主要用于Redis数据的异步删除；
>
> 而在Redis6/7中引入了I/O多线程的读写，这样就可以更加高效的处理更多的任务了，**Redis只是将I/O读写变成了多线程**，而**命令执行依旧是由主线程串行执行**，因此在多线程下操作Redis不会出现线程安全的问题了。
>
> **Redis无论是当初的单线程设计，还是如今与放出设计相背的多线程，目的只有一个：让Redis变得越来越快**。

# 2、BigKey

# 3、缓存双写一致性之更新策略探讨

# 4、Redis与MySQL数据双写一致性工程落地案例

# 5、案例落地实战BitMap/HyperLogLog/GEO

# 6、布隆过滤器BloomFilter

# 7、缓存预热 + 缓存雪崩 + 缓存击穿

# 8、手写Redis分布式锁

# 9、Redlock算法和底层源码分析

# 10、Redis的缓存过期淘汰策略

# 11、Redis经典五大类型源码及底层实现

# 12、Redis为什么快？高性能设计之epoll和IO多路复用深度解析

# 13、终章总结